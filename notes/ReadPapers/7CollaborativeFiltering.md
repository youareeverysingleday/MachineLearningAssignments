# Collaborative Filtering协同过滤

主要是为了读两篇何向南的论文服务的。

## 参考

1. [什么是协同过滤，这一篇对基于启发式的协同过滤讲得很明白，而且里面还举了具体的例子](https://www.jianshu.com/p/5463ab162a58)。

## 相关知识点

1. 协同过滤算法分为两种：基于启发式和基于模型式。
2. 概念说明：协同过滤简单来说是利用某兴趣相投、拥有共同经验之群体的喜好来推荐用户感兴趣的信息，个人通过合作的机制给予信息相当程度的回应（如评分）并记录下来以达到过滤的目的进而帮助别人筛选信息，回应不一定局限于特别感兴趣的，特别不感兴趣信息的纪录也相当重要。

### 基于启发式

1. 分类：基于启发式的协同过滤又可以分为两种：基于用户的协同过滤算法和基于项目的协同过滤算法。
2. 启发式协同过滤算法主要包含3个步骤：
   1. 收集用户偏好信息
   2. 寻找相似的商品或者用户
   3. 产生推荐。
3. 基于用户的协同过滤算法（user-based）
   1. 假设：**相同的人有相同的选择**。
   2. 主要的思路：**寻找与对象用户偏好相同的用户，以相同用户喜欢的商品作为对象用户喜欢的商品进行推荐**。基于用户（User-Based）的协同过滤算法首先要根据用户历史行为信息，寻找与新用户相似的其他用户；同时，根据这些相似用户对其他项的评价信息预测当前新用户可能喜欢的项。
   3. 采用的算法：根据数据的不同来选择不同的算法：目前较多使用的相似度算法有Pearson Correlation Coefficient（皮尔逊相关系数）、Cosine-based Similarity（余弦相似度）、Adjusted Cosine Similarity（调整后的余弦相似度）。
   4. 另一个重要环节在于：计算用户对未评分商品的预测分值。计算步骤如下：
      1. 寻找研究对象用户的邻居们（多个邻居）。
      2. 计算邻居们对指定item的评分。
      3. 结合研究对象的其他历史评分和邻居们的评分，给出指定商品的评分。
      4. 最后根据多个评分的高低给出推荐。
   5. 缺点：
      1. 随着用户的增多计算时间就会变长（难道随着历史数据的增加不会使准确率提高吗？）。因此提出了基于item的协同过滤。
      2. 需要用户的历史数据。
      3. 需要对用户进行识别。也就是需要对每一个用户进行唯一标识。
4. 基于项目的协同过滤算法（item-based）
   1. 假设：通过user选择查看的物品，然后推荐给user与查看item类似的物品。
   2. 主要思路：计算item之间的相似度，从而预测用户的评分。如果两个item被大量的用户同时购买，那么认为两个item的相似度高，反之则低；再给新的用户推荐时，通过之前计算的每个item之间两两的相似度，然后推荐给user历史访问item相似的item。这个过程中就涉及冷启动的问题。
   3. 步骤：
      1. 收集用户偏好信息。
      2. 计算以评价item和待预测item的相似度，并以相似度作为权重，加权各已评价item的分数，得到待预测项目的预测值。
      3. 产生推荐结果。
   4. item之间相似度的计算法方法：item之间相似度计算公式$\boldsymbol{w}_{ij}=\frac{|\boldsymbol{N}(i)\bigcap \boldsymbol{N}(j)|}{\sqrt{|\boldsymbol{N}(i)||\boldsymbol{N}(j)|}}$。分母$|\boldsymbol{N}(i)|$是喜欢物品i的用户数，而分子$|\boldsymbol{N}(i)|\bigcap \boldsymbol{N}(j)$是同时喜欢物品i和j的用户，但是如果物品j很热门，就会导致$\boldsymbol{w}_{ij}$很大接近于1。因此避免推荐出热门的物品，在分母取了根号。从上面的定义可以看出，**在协同过滤中两个物品产生相似度是因为他们共同被很多用户喜欢，也就是说每个用户都可以通过他们的历史兴趣列表给物品“贡献”相似度**。计算物品相似度首先建立用户-物品倒排表（即对每个用户建立一个包含他喜欢的物品的列表），然后对每个用户，将他物品列表中的物品两两在**共现矩阵**中加1。
   5. 优点：
      1. 不需要对用户进行识别。
      2. 不需要用户的历史数据。
      3. item之间的相似性相对于user之间的相似性要稳定得多。基于此，可以离线完成计算工作，提高了推荐效率。尤其是在user多于item的情况下尤为显著。
   6. 缺点：
      1. 精度比较差。由于没有考虑user之间的差异。

### 基于模型式

大概的思路：首先建立user和item的交互矩阵；然后将该矩阵进行因式分解为两个矩阵，一个是user矩阵，一个是item矩阵。它们都将user和item投影到了一个隐性空间中。然后推荐的时候，推荐时，针对一个user和所有item进行计算，然后取结果高的作为推荐结果。（这难道不是因式分解吗？）

还需要进一步补充。这个也可以通过神经网络来计算这种结果。

## 问题

1. “尤其是在user多于item的情况下尤为显著。”如何理解？
    - 答：user越多，那么item之间的相似性就越准。这样在推荐item时就会越准。

--END--
